mod private;

use crate::{DataFormat, EncodableType, FormatType};
use private::{Bounds, CompoundTypeExtDef, Content, Sealed};

pub use cu29_derive::CompoundType;

pub struct FieldDescriptor<FieldType> {
    pub name: &'static str,
    pub default: Option<FieldType>,
}
impl<FieldType> FieldDescriptor<FieldType> {
    pub const fn no_default(name: &'static str) -> Self {
        Self {
            name,
            default: None,
        }
    }
}

pub struct VariantDescriptor<Struct> {
    pub name: &'static str,
    pub fields: Struct,
}
impl<Struct> VariantDescriptor<Struct> {
    pub const fn new(name: &'static str, fields: Struct) -> Self {
        Self { name, fields }
    }
}

pub type Desc<C> = <C as Content>::Descriptor;

/// A compound type (typically comprising multiple fields).
///
/// Implementations of this trait are generated by the [`CompoundType`][derive@CompoundType]
/// derive macro, which is the recommended way to implement it.  Explicit implementations are
/// likely only to be defined locally in this crate, for upstream library types.
///
/// Consumers of this trait should typically use its [`CompoundType`] subtrait instead, which
/// avoids any need to name the `'this` lifetime parameter.  The `ImplicitBounds` parameter
/// exists only to facilitate that (and in any event cannot be named owing to its `Sealed`
/// constraint: the default of [`Bounds<'this, Self>`] is the only type that the parameter
/// can or should be).  In effect this enables the associated `Descriptor` type to be
/// generic over the `'this` lifetime parameter in a usable way.
///
/// See [The Better Alternative to Lifetime GATs] for more information.
///
/// [The Better Alternative to Lifetime GATs]: https://sabrinajewson.org/blog/the-better-alternative-to-lifetime-gats
pub trait CompoundTypeDef<'this, ImplicitBounds: Sealed = Bounds<'this, Self>> {
    /// The intermediate representation into which this compound type is lowered by
    /// [`CompoundTypeDef::intermediate`].  Due to this trait's `'this` lifetime parameter,
    /// the intermediate representation can borrow from the compound type itself.
    ///
    /// Implementors may find it convenient to use the [`Cons`] (and, for enums, also the
    /// [`Alt`]) macros to construct the intermediate representation.
    ///
    /// [`Cons`]: crate::Cons
    /// [`Alt`]: crate::Alt
    type Intermediate: Content;

    /// Descriptors for the fields in this compound type's intermediate representation.
    ///
    /// Implementors may find it convenient to use the [`cons`] macro to construct the list.
    ///
    /// [`cons`]: crate::cons
    const DESCRIPTOR: Desc<Self::Intermediate>;

    /// Marshals a value of this compound type into its intermediate representation.
    ///
    /// Implementors may find it convenient to use the [`cons`] (and, for enums, also the
    /// [`alt`]) macros to construct a value of the intermediate representation.
    ///
    /// [`cons`]: crate::cons
    /// [`alt`]: crate::alt
    fn intermediate(&'this self) -> Self::Intermediate;
}

/// [`EncodableType::Sigil`] sigil for [`CompoundType`]s.
pub enum Compound {}

/// A compound type (typically comprising multiple fields).
///
/// Implementations of this trait are generated by the [`CompoundType`][derive@CompoundType]
/// derive macro, which is the recommended way to implement it.  Explicit implementations are
/// likely only to be defined locally in this crate, for upstream library types.
///
/// When such a compound type is required in a particular [`DataFormat`], consumers should
/// typically use this trait's [`CompoundTypeExt<Format>`] subtrait instead as that provides
/// the schema and encodable fields for that format.
pub trait CompoundType:
    EncodableType<Sigil = Compound> + for<'this> CompoundTypeDef<'this>
{
}
impl<T: EncodableType<Sigil = Compound> + for<'this> CompoundTypeDef<'this>> CompoundType for T {}

/// A blanket-implemented extension trait that (through its unnameable `CompoundTypeExtDef`
/// supertrait) provides convenient access to the schema of a compound type's fields, and the
/// list of encodable field values.
pub trait CompoundTypeExt<Format: DataFormat>
where
    Self: CompoundType + for<'this> CompoundTypeExtDef<'this, Format>,
{
}
impl<Format: DataFormat, T> CompoundTypeExt<Format> for T where
    T: CompoundType + for<'this> CompoundTypeExtDef<'this, Format>
{
}

/// Proxy trait for implementing [`Encodes<T>`] when `T` is a [`CompoundType`].
///
/// [`DataFormat`] definers will typically want to implement this trait for generic `T`, to
/// describe how that format encodes [`CompoundType`]s.
///
/// Consumers will usually want to use [`Encodes<T>`] instead, which is blanket implemented
/// for implementers of this trait (but also for other [`EncodableType`]s).
///
/// [`Encodes<T>`]: crate::Encodes<T>
pub trait EncodesCompound<T: ?Sized + EncodableType<Sigil = Compound>>: DataFormat {
    type CompoundFormatType<'a>: FormatType<Self>
    where
        T: 'a;
    fn complex_encodable(t: &T) -> Self::CompoundFormatType<'_>;
}
