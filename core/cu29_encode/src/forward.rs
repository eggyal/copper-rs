use super::{DataFormat, EncodableType, Encodes, FormatType};
use bincode::{enc::Encoder, error::EncodeError, Encode};
use core::marker::PhantomData;

/// Creates [`ForwardingType`]s via borrowed values.
#[macro_export]
macro_rules! delegate {
    ($(fn$([$($lt:lifetime, )?$t:ident$(: $($bounds:tt)+)?])?($self:ident: $from:ty) -> $to:ty { $def:expr })*) => {$(
        impl<$($($lt, )?)?Format: $crate::Encodes<$to>$(, $t: $crate::EncodableType $(+ $($bounds)+)?)?> $crate::forward::EncodesForwarding<$from> for Format {
            type ForwardingFormatType<'a> = <Format as $crate::Encodes<$to>>::FormatType<'a> where $from: 'a;
            #[allow(clippy::needless_lifetimes)]
            fn forward_encodable<'a>($self: &'a $from) -> Self::ForwardingFormatType<'a> {
                let def: &$to = &$def;
                Self::encodable(def)
            }
        }
        impl$(<$($lt, )?$t: $crate::EncodableType$(+ $($bounds)+)?>)? $crate::NameableType for $from {
            //FIXME: should this generate a name for $from instead ?
            const NAME: &'static dyn ::core::fmt::Display = <$to as $crate::NameableType>::NAME;
        }
        impl$(<$($lt, )?$t: $crate::EncodableType$(+ $($bounds)+)?>)? $crate::EncodableType for $from {
            type Sigil = $crate::forward::Forwarding;
        }
        impl$(<$($lt, )?$t: $crate::EncodableType$(+ $($bounds)+)?>)? $crate::forward::ForwardingType for $from {}
    )*};
}

/// Creates [`ForwardingType`]s via owned values.
#[macro_export]
macro_rules! defer {
    ($(fn$([$($lt:lifetime, )?$t:ident$(: $($bounds:tt)+)?])?($self:ident: $from:ty) -> $to:ty { $def:expr })*) => {$(
        impl<$($($lt, )?)?Format: $crate::Encodes<$to>$(, $t: $crate::EncodableType $(+ $($bounds)+)?)?> $crate::forward::EncodesForwarding<$from> for Format {
            type ForwardingFormatType<'a> = $crate::forward::Defer<$to, Format> where $from: 'a;
            #[allow(clippy::needless_lifetimes)]
            fn forward_encodable<'a>($self: &'a $from) -> Self::ForwardingFormatType<'a> {
                $crate::forward::Defer::new($def)
            }
        }
        impl$(<$($lt, )?$t: $crate::EncodableType$(+ $($bounds)+)?>)? $crate::NameableType for $from {
            //FIXME: should this generate a name for $from instead ?
            const NAME: &'static dyn ::core::fmt::Display = <$to as $crate::NameableType>::NAME;
        }
        impl$(<$($lt, )?$t: $crate::EncodableType$(+ $($bounds)+)?>)? $crate::EncodableType for $from {
            type Sigil = $crate::forward::Forwarding;
        }
        impl$(<$($lt, )?$t: $crate::EncodableType$(+ $($bounds)+)?>)? $crate::forward::ForwardingType for $from {}
    )*};
}

/// [`EncodableType::Sigil`] sigil for [`ForwardingType`]s.
pub enum Forwarding {}
pub trait ForwardingType: EncodableType<Sigil = Forwarding> {}

/// Proxy trait for implementing [`Encodes<T>`] when `T` is a [`ForwardingType`].
///
/// Implementations of this trait are generated by the [`defer`] and [`delegate`] macros,
/// which are the recommended ways to implement it.
///
/// Consumers will usually want to use [`Encodes<T>`] instead, which is blanket implemented
/// for implementers of this trait (but also for other [`EncodableType`]s).
pub trait EncodesForwarding<T: ?Sized + EncodableType<Sigil = Forwarding>>: DataFormat {
    type ForwardingFormatType<'a>: FormatType<Self>
    where
        T: 'a;
    fn forward_encodable(t: &T) -> Self::ForwardingFormatType<'_>;
}

pub struct Defer<D, Format>(pub D, PhantomData<Format>);
impl<D, Format> Defer<D, Format> {
    pub fn new(d: D) -> Self {
        Self(d, PhantomData)
    }
}
impl<D: EncodableType, Format: Encodes<D>> FormatType<Format> for Defer<D, Format>
where
    Self: Encode,
{
    const FIELD_TYPE: Format::FieldType = Format::FormatType::FIELD_TYPE;
}

impl<D: EncodableType, Format: Encodes<D>> Encode for Defer<D, Format> {
    fn encode<E: Encoder>(&self, encoder: &mut E) -> Result<(), EncodeError> {
        Format::encodable(&self.0).encode(encoder)
    }
}
