//! Schemaful serialisation of self-describing data types.
//!
//! This crate is decoupled from any particular serialisation format.
//! It provides machinery that lowers values of Rust types into an
//! intermediate representation, which downstream libraries can then
//! serialise according to their own specification.  In this regard,
//! it is conceptually somewhat similar to serde.  Where it differs
//! (besides the API) is that it also provides "descriptions" of the
//! types so-lowered such that downstream libraries can also generate
//! schema for their serialisations; these descriptions are generated
//! at compile-time via Rust's trait system and ensure coherance with
//! the intermediate representation.
//!
//! At a high level, an [`EncodableType`] is anything that can be
//! lowered to an intermediate representation; they are divided into
//! three subtypes, as indicated by their associated
//! [`EncodableType::Sigil`] sigil type:
//! - [`ElementType`]s (having the crate-private `Element` sigil),
//!   which are the basic building blocks of the intermediate
//!   representation;
//! - [`CompoundType`]s (having the [`Compound`] sigil), which can be
//!   arbitrary structs or enums composed of other [`EncodableType`]s;
//!   and
//! - [`ForwardingType`]s (having the [`Forwarding`] sigil), which are
//!   types that lower to some other [`EncodableType`].
//!
//! Only this crate can define new [`ElementType`]s.  Downstream types
//! that wish to be serialisable must be either compound or forwarding:
//! - all types can be considered compound, and this is the most
//!   powerful and most flexible option—it is likely to be used in most
//!   situations; the [`CompoundType`][derive@CompoundType] derive
//!   macro should suffice for most implementations.  However, compound
//!   types add a layer of indirection that may be undesirable.
//! - only types for which there is already an existing suitable
//!   intermediate representation can be considered forwarding—it is
//!   likely to be used only for simple library types that in some way
//!   wrap another [`EncodableType`]; one of the [`defer`], [`delegate`]
//!   or [`iterate`] macros should suffice for most implementations.
//!
//! Downstream implementors of a serialisation format will define a
//! [`DataFormat`], and then implement for it [`EncodesElement`] and
//! [`EncodesCompound`] parameterised by each such type that it is able
//! to serialise.  Typically, there will be an [`EncodesElement`]
//! implementation for each supported [`ElementType`] and a single
//! generic [`EncodesCompound`] implementation that handles arbitrary
//! [`CompoundType`]s.
//!
//! The [`Encodes`] trait is blanket implemented on all [`DataFormat`]s
//! for every [`EncodableType`] that they support, and provides the
//! interface for performing serialisation operations and generating
//! schemas.
//!
//! [`ElementType`]: element::ElementType
//! [`CompoundType`]: compound::CompoundType
//! [`Compound`]: compound::Compound
//! [`ForwardingType`]: forward::ForwardingType
//! [`Forwarding`]: forward::Forwarding
//!
//! [derive@CompoundType]: derive@compound::CompoundType
//!
//! [`EncodesElement`]: element::EncodesElement
//! [`EncodesCompound`]: compound::EncodesCompound

extern crate self as cu29_encode;

pub mod type_list;

pub mod compound;
pub mod element;
pub mod forward;

mod intermediate;
mod upstream;

use core::fmt;

/// Provides access to a statically defined name for this type.
///
/// The name should uniquely identify the type.
///
/// Implementations of this trait are generated by the [`defer`], [`delegate`], [`iterate`]
/// and [`CompoundType`] macros (as well as the crate-private `elements` and `tuples` macros),
/// which are the recommended ways to implement it.  Explicit implementations are likely only
/// to be defined locally in this crate, for upstream library types.
///
/// [`CompoundType`]: derive@compound::CompoundType
pub trait NameableType {
    // Ideally, the compiler would provide a unique type name for us, eg via something like
    // [`std::any::type_name`]—but alas that's not stable const, uniqueness is not guaranteed,
    // and the names that it produces aren't stable.
    //
    // Instead, we generate "type names" ourselves at compile-time by recursively concatenating
    // literals together with the names of any other involved types.
    // TODO:? we could guarantee uniqueness by using type-level strings that project back to the
    //        relevant type...
    //
    // It's a little bit annoying that we need to use the indirection of a trait object here,
    // but unfortunately that's necessary to work around the inability to otherwise promote
    // const-context variables to statics.  Nevertheless the use of these constants is pretty
    // rare (just once per occurrence within a schema), so the indirection is unlikely to be
    // a material expense.
    const NAME: &dyn fmt::Display;
}

/// A type that can be lowered to an intermediate representation for onward serialisation by
/// [`DataFormat`]s.
///
/// Implementations of this trait are generated by the [`defer`], [`delegate`], [`iterate`]
/// and [`CompoundType`] macros (as well as the crate-private `elements` and `tuples` macros),
/// which are the recommended ways to implement it.  Explicit implementations are likely only
/// to be defined locally in this crate, for upstream library types.
///
/// This trait should not need to be consumed outside of this crate.
///
/// [`CompoundType`]: derive@compound::CompoundType
pub trait EncodableType: NameableType {
    type Sigil: intermediate::Sigil;
}

/// A data format determines how messages are serialised.
pub trait DataFormat {
    /// The field type of a data format describes any serialised datum's type
    /// in the data format's serialisation schema.
    type FieldType;
    type EncodableAlt<List>: From<List>;
    type EncodableCons<List>: From<List>;
    type UnboundedIterator<Iter: Clone + IntoIterator<Item: EncodableType>, const ORDER_DEFINED: bool>: From<Iter> + FormatType<Self> where Self: Encodes<Iter::Item>;
    type BoundedIterator<Iter: Clone + IntoIterator<Item: EncodableType>, const ORDER_DEFINED: bool, const MAX: usize>: From<Iter> + FormatType<Self> where Self: Encodes<Iter::Item>;
    type StaticLenIterator<Iter: Clone + IntoIterator<Item: EncodableType>, const ORDER_DEFINED: bool, const LEN: usize>: From<Iter> + FormatType<Self> where Self: Encodes<Iter::Item>;
}

/// A format type is a serializable datum that knows its type in `Format`'s
/// serialisation schema.
pub trait FormatType<Format: ?Sized + DataFormat>: bincode::Encode {
    const FIELD_TYPE: Format::FieldType;
}

/// The interface through which [`EncodableType`]s can be lowered into their
/// [`DataFormat`]-specific representation.
pub trait Encodes<T: ?Sized + EncodableType>: intermediate::UnifiedEncodes<T, T::Sigil> {
    type FormatType<'a>: FormatType<Self>
    where
        T: 'a;
    fn encodable(t: &T) -> Self::FormatType<'_>;
}
