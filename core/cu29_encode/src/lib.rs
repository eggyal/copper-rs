//! Schemaful serialisation of self-describing data types.
//!
//! This crate is decoupled from any particular serialisation format.
//! It provides machinery that transforms [`Lowerable`]s into a format-
//! agnostic intermediate representation, which downstream libraries can
//! then further transform into [`Lowered`]s that can be serialised
//! according to their needs: it does this with minimal (often zero)
//! runtime overhead.  In this regard, it is conceptually somewhat
//! similar to [serde]; where it differs (besides the API) is that it
//! also provides "descriptions" of the types so-lowered such that
//! downstream libraries can also generate schema for their
//! serialisations; these descriptions are generated at compile-time via
//! Rust's trait system and ensure coherance with the intermediate
//! representation.
//!
//! At a high level, a [`Lowerable`] is anything that can be lowered to
//! this crate's format-agnostic intermediate representation; they are
//! divided into three subtypes, as indicated by their associateds
//! [`Lowerable::Sigil`] sigil type:
//! - [`LowerableElement`]s (having the crate-private `Element` sigil),
//!   whose intermediate representation is themselves;
//! - [`LowerableCompound`]s (having the [`Compound`] sigil), which can be
//!   arbitrary (enums or) structs composed of other [`Lowerable`]s—their
//!   intermediate representation is (an [`Alt`] list of their variants each
//!   comprising) a [`Cons`]-list of their fields;
//!   and
//! - [`LowerableVia`]s (having the [`Forwarding`] sigil), which are types
//!   that lower via some other [`Lowerable`].
//!
//! Only this crate can define new [`LowerableElement`]s.  Downstream types
//! that wish to be serialisable must be either compound or forwarding:
//! - all types can be considered compound, and this is the most
//!   powerful and most flexible option—it is likely to be used in most
//!   situations; the [`LowerableCompound`][derive@LowerableCompound] derive
//!   macro should suffice for most implementations.  However, compound
//!   types add a layer of indirection that may be undesirable.
//! - only types for which there is already an existing suitable
//!   intermediate representation can be considered forwarding—it is
//!   likely to be used only for simple types that in some way wrap another
//!   [`Lowerable`]; one of the [`defer`], [`delegate`] or [`iterate`]
//!   macros should suffice for most implementations.
//!
//! Downstream implementors of a serialisation format will define a
//! [`DataFormat`], and then implement for it [`LowersElement`] and
//! [`LowersCompound`] parameterised by each such type that it is able
//! to serialise.  Typically, there will be a [`LowersElement`]
//! implementation for each supported [`LowerableElement`] and a single
//! generic [`LowersCompound`] implementation that handles arbitrary
//! [`LowerableCompound`]s.
//!
//! The [`Lowers`] trait is blanket implemented on all [`DataFormat`]s
//! for every [`Lowerable`] that they support, and provides the
//! interface for performing serialisation operations and generating
//! schemas.
//!
//! [serde]: https://crates.io/crates/serde
//!
//! [`LowerableElement`]: element::LowerableElement
//! [`LowerableCompound`]: compound::LowerableCompound
//! [`Compound`]: compound::Compound
//! [`Alt`]: type_list::Alt
//! [`Cons`]: type_list::Cons
//! [`LowerableVia`]: forward::LowerableVia
//! [`Forwarding`]: forward::Forwarding
//!
//! [derive@LowerableCompound]: derive@compound::LowerableCompound
//!
//! [`LowersElement`]: element::LowersElement
//! [`LowersCompound`]: compound::LowersCompound

extern crate self as cu29_encode;

pub mod type_list;

pub mod compound;
pub mod element;
pub mod forward;

mod intermediate;
mod upstream;

use core::fmt;

/// A type that can be lowered to an intermediate representation for onward serialisation by
/// [`DataFormat`]s.
///
/// Implementations of this trait are generated by the [`defer`], [`delegate`], [`iterate`]
/// and [`LowerableCompound`] macros (as well as the crate-private `elements` and `tuples` macros),
/// which are the recommended ways to implement it.  Explicit implementations are likely only
/// to be defined locally in this crate, for upstream library types.
///
/// This trait should not need to be consumed outside of this crate.
///
/// [`LowerableCompound`]: derive@compound::LowerableCompound
pub trait Lowerable {
    /// Provides access to a statically defined name for this type.
    ///
    /// The name should uniquely identify the type.
    // Ideally, the compiler would provide a unique type name for us, eg via something like
    // [`std::any::type_name`]—but alas that's not stable const, uniqueness is not guaranteed,
    // and the names that it produces aren't stable.
    //
    // Instead, we generate "type names" ourselves at compile-time by recursively concatenating
    // literals together with the names of any other involved types.
    // TODO:? we could guarantee uniqueness by using type-level strings that project back to the
    //        relevant type...
    //
    // It's a little bit annoying that we need to use the indirection of a trait object here,
    // but unfortunately that's necessary to work around the inability to otherwise promote
    // const-context variables to statics.  Nevertheless the use of these constants is pretty
    // rare (just once per occurrence within a schema), so the indirection is unlikely to be
    // a material expense.
    const NAME: &dyn fmt::Display;
    type Sigil: intermediate::Sigil;
}

/// A data format determines how messages are serialised.
pub trait DataFormat {
    /// The field type of a data format describes any serialised datum's type
    /// in the data format's serialisation schema.
    type FieldType;
    type EncodableAlt<List>: From<List>;
    type EncodableCons<List>: From<List>;
    type UnboundedIterator<Iter: Clone + IntoIterator<Item: Lowerable>, const ORDER_DEFINED: bool>: From<Iter> + Lowered<Self> where Self: Lowers<Iter::Item>;
    type BoundedIterator<Iter: Clone + IntoIterator<Item: Lowerable>, const ORDER_DEFINED: bool, const MAX: usize>: From<Iter> + Lowered<Self> where Self: Lowers<Iter::Item>;
    type StaticLenIterator<Iter: Clone + IntoIterator<Item: Lowerable>, const ORDER_DEFINED: bool, const LEN: usize>: From<Iter> + Lowered<Self> where Self: Lowers<Iter::Item>;
}

/// A format type is a serializable datum that knows its type in `Format`'s
/// serialisation schema.
pub trait Lowered<Format: ?Sized + DataFormat>: bincode::Encode {
    const FIELD_TYPE: Format::FieldType;
}

/// The interface through which [`Lowerable`]s can be lowered into their
/// [`DataFormat`]-specific representation.
pub trait Lowers<T: ?Sized + Lowerable>: intermediate::LowersUnified<T, T::Sigil> {
    type Lowered<'a>: Lowered<Self>
    where
        T: 'a;

    /// Lowers a value of type `T`, via its format-agnostic intermediate representation,
    /// to the relevant [`Lowered`] of the specific `Self` format.
    fn lower(t: &T) -> Self::Lowered<'_>;
}
